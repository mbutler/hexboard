var $=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var S=$((D,M)=>{var P=new RegExp("(bold|bolder|lighter|[1-9]00) +","i"),E=new RegExp("(italic|oblique) +","i"),I=new RegExp("(small-caps) +","i"),O=new RegExp("(ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded) +","i"),N=new RegExp('([\\d\\.]+)(px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q) *((?:\'([^\']+)\'|"([^"]+)"|[\\w\\s-]+)( *, *(?:\'([^\']+)\'|"([^"]+)"|[\\w\\s-]+))*)'),m={};M.exports=(e)=>{if(m[e])return m[e];const t=N.exec(e);if(!t)return;const n={weight:"normal",style:"normal",stretch:"normal",variant:"normal",size:parseFloat(t[1]),unit:t[2],family:t[3].replace(/["']/g,"").replace(/ *, */g,",")};let o,s,r,i;const c=e.substring(0,t.index);if(o=P.exec(c))n.weight=o[1];if(s=E.exec(c))n.style=s[1];if(r=I.exec(c))n.variant=r[1];if(i=O.exec(c))n.stretch=i[1];switch(n.unit){case"pt":n.size/=0.75;break;case"pc":n.size*=16;break;case"in":n.size*=96;break;case"cm":n.size*=37.79527559055118;break;case"mm":n.size*=3.7795275590551185;break;case"%":break;case"em":case"rem":n.size*=21.333333333333332;break;case"q":n.size*=0.9448818897637796;break}return m[e]=n}});var{default:T}=(()=>({}));var{default:v}=(()=>({}));var R=S();var d=function(e,t){return Object.assign(document.createElement("canvas"),{width:e,height:t})};class z{constructor(e){this.size=e,this.grid=this.createHexGrid()}lerp(e,t,n){return e+(t-e)*n}movementTable(e="flat"){return(e==="flat"?[[1,-1,0],[0,-1,1],[-1,0,1],[-1,1,0],[0,1,-1],[1,0,-1]]:[[1,0,-1],[1,-1,0],[0,-1,1],[-1,0,1],[-1,1,0],[0,1,-1]]).reduce((n,o,s)=>{return n[s]=o,n},{})}createHexGrid(){const e={};for(let t=-this.size;t<=this.size;t++)for(let n=Math.max(-this.size,-t-this.size);n<=Math.min(this.size,-t+this.size);n++){const o=-t-n,s=`${t},${n},${o}`;e[s]={}}return e}getHexagon(e){const{x:t,y:n,z:o}=e;return this.grid[`${t},${n},${o}`]||null}hexesInRange(e,t,n=!1){const o=[];for(let s=-t;s<=t;s++)for(let r=Math.max(-t,-s-t);r<=Math.min(t,-s+t);r++){const i=-s-r,c={x:e.x+s,y:e.y+r,z:e.z+i};if(n&&c===e)continue;o.push(c)}return o}neighbors(e){return this.hexesInRange(e,1,!0)}getProperties(e,t=null){const n=`${e.x},${e.y},${e.z}`,o=this.grid[n]||null;if(!o)return null;if(t)return t.reduce((s,r)=>{return s[r]=o[r]||null,s},{});else return o}setProperties(e,t){const n=`${e.x},${e.y},${e.z}`;if(this.grid[n])return Object.assign(this.grid[n],t),!0;else return!1}getRelativeCoordinates(e,t,n){const[o,s,r]=this.movementTable()[t];return{x:e.x+o*n,y:e.y+s*n,z:e.z+r*n}}cubeDistance(e,t){return Math.max(Math.abs(e.x-t.x),Math.abs(e.y-t.y),Math.abs(e.z-t.z))}cubeRound(e){let t=Math.round(e.x),n=Math.round(e.y),o=Math.round(e.z);const s=Math.abs(t-e.x),r=Math.abs(n-e.y),i=Math.abs(o-e.z);if(s>r&&s>i)t=-n-o;else if(r>i)n=-t-o;else o=-t-n;return{x:t,y:n,z:o}}hexesInPath(e,t){const n=this.cubeDistance(e,t),o=[];for(let s=0;s<=n;s++){const r=1/n*s,i={x:this.lerp(e.x,t.x,r),y:this.lerp(e.y,t.y,r),z:this.lerp(e.z,t.z,r)};o.push(this.cubeRound(i))}return o}hexRangeIntersection(e,t,n,o){const s=this.hexesInRange(e,t),r=this.hexesInRange(n,o);return s.filter((i)=>r.includes(i))}floodFill(e,t){const n=Array.from({length:t+1},()=>[]);n[0].push(e);for(let o=1;o<=t;o++)for(let s of n[o-1])for(let r=0;r<6;r++){const i=this.getRelativeCoordinates(s,r,1);if(n.some((x)=>x.includes(i)))continue;if(this.getProperties(i)?.obstacle)continue;n[o].push(i)}return n}updatePropertiesFromList(e){for(let t of e)if(t.coords&&t.props){const n=Object.values(t.coords);this.setProperties(n,t.props)}else throw new Error("Hexagon object must contain 'coords' and 'props' keys.");return this.grid}directionToIndex(e,t="flat"){const n=t==="flat"?{NE:0,SE:1,S:2,SW:3,NW:4,N:5}:{NE:0,E:1,SE:2,SW:3,W:4,NW:5};if(!n[e])throw new Error(`Invalid direction. Choose from ${Object.keys(n)}.`);return n[e]}indexToDirection(e,t="flat"){const n=t==="flat"?{0:"NE",1:"SE",2:"S",3:"SW",4:"NW",5:"N"}:{0:"NE",1:"E",2:"SE",3:"SW",4:"W",5:"NW"};if(!n[e])throw new Error(`Invalid index. Choose from ${Object.keys(n)}.`);return n[e]}flatHexCorner(e,t,n){const o=60*n,s=Math.PI/180*o;return{x:e.x+t*Math.cos(s),y:e.y+t*Math.sin(s)}}hexToPixel(e,t,n,o="flat"){const[s,r,i]=e.split(",").map(Number),c=o==="flat"?t*(1.5*s):t*(Math.sqrt(3)*(s+r/2)),x=o==="flat"?t*(Math.sqrt(3)*(r+s/2)):t*(1.5*r),g=t*n,h=t*n;return{x:c+g,y:x+h}}drawGrid(e,t="hexagons.png"){const o=d(1000,1000).getContext("2d");let s=1/0,r=1/0,i=-1/0,c=-1/0;for(let a of Object.keys(this.grid)){const f=this.hexToPixel(a,e,this.size,"flat");s=Math.min(s,f.x),r=Math.min(r,f.y),i=Math.max(i,f.x),c=Math.max(c,f.y)}const x=e,g=[i-s+2*x,c-r+2*x],h=d(g[0],g[1]),l=h.getContext("2d");for(let a of Object.keys(this.grid)){const f=this.hexToPixel(a,e,this.size,"flat");f.x-=s-x,f.y-=r-x;const p=Array.from({length:6},(u,y)=>this.flatHexCorner(f,e,y)).map((u)=>[u.x,u.y]);l.beginPath(),l.moveTo(p[0][0],p[0][1]),p.slice(1).forEach(([u,y])=>l.lineTo(u,y)),l.closePath(),l.stroke()}v.writeFileSync(t,h.toBuffer("image/png"))}toJSON(){return JSON.stringify(this.grid)}fromJSON(e){this.grid=JSON.parse(e)}}var b=z;async function W(){const e=Date.now(),n=new b(1000);for(let h=0;h<1000;h++)for(let l=0;l<1000;l++)for(let a=0;a<1000;a++)if(h+l+a===0)n.setProperties({x:h,y:l,z:a},{value:h*l*a});n.setProperties({x:0,y:0,z:0},{terrain:"grassland",elevation:100});const o={x:0,y:0,z:0},s=50,r=n.hexesInRange(o,s,!1);console.log(`Number of hexes in range: ${r.length}`);const i=n.neighbors(o);console.log(`Number of neighbors: ${i.length}`);const c=n.getRelativeCoordinates(o,2,5);console.log(`Relative coordinates: ${JSON.stringify(c)}`);const x=n.toJSON();T.writeFileSync("hex_grid.json",x);const g=(Date.now()-e)/1000;console.log(`Elapsed time: ${g.toFixed(2)} seconds`)}W();
